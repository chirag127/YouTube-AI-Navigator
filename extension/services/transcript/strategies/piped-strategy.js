// Piped API Strategy
// Priority: 2.5 (Between Invidious and YouTube Direct)
// Piped is a privacy-friendly YouTube frontend with API

import { parseXML } from '../parsers/xml-parser.js'

const INSTANCES = [
    'https://api.piped.private.coffee',
    'https://pipedapi.adminforge.de',
    'https://pipedapi.kavin.rocks',
    'https://api-piped.mha.fi',
    'https://pipedapi.aeong.one'
]

export async function fetchViaPiped(videoId, lang = 'en') {
    for (const instance of INSTANCES) {
        try {
            // Fetch video streams data which includes subtitles
            const url = `${instance}/streams/${videoId}`
            const res = await fetch(url, { signal: AbortSignal.timeout(8000) })

            if (!res.ok) continue

            const data = await res.json()

            if (!data.subtitles?.length) {
                throw new Error('No subtitles available')
            }

            // Find subtitle track for requested language
            let subtitle = data.subtitles.find(s => s.code === lang)
            if (!subtitle) {
                // Try auto-generated if exact match not found
                subtitle = data.subtitles.find(s => s.code === lang && s.autoGenerated)
            }
            if (!subtitle) {
                // Fallback to first available
                subtitle = data.subtitles[0]
            }

            // Fetch subtitle content
            const subtitleUrl = subtitle.url
            const subtitleRes = await fetch(subtitleUrl, { signal: AbortSignal.timeout(10000) })

            if (!subtitleRes.ok) continue

            const subtitleText = await subtitleRes.text()

            // Piped returns subtitles in various formats (usually TTML/XML)
            const segments = parseSubtitleFormat(subtitleText, subtitle.mimeType)

            if (segments.length > 0) {
                return segments
            }
        } catch (e) {
            continue
        }
    }

    throw new Error('All Piped instances failed')
}

function parseSubtitleFormat(text, mimeType) {
    // Handle different subtitle formats
    if (mimeType?.includes('ttml') || mimeType?.includes('xml')) {
        return parseTTML(text)
    } else if (mimeType?.includes('vtt')) {
        // Import VTT parser if needed
        return parseVTTFormat(text)
    } else {
        // Try XML as fallback
        return parseXML(text)
    }
}

function parseTTML(ttmlText) {
    const segments = []

    // TTML format: <p begin="00:00:10.500" end="00:00:12.800">Hello world</p>
    const regex = /<p\s+begin="([^"]+)"\s+end="([^"]+)"[^>]*>([^<]*)<\/p>/g
    let match

    while ((match = regex.exec(ttmlText))) {
        const start = parseTTMLTime(match[1])
        const end = parseTTMLTime(match[2])
        const text = decodeHTML(match[3])

        if (text.trim()) {
            segments.push({
                start,
                duration: end - start,
                text
            })
        }
    }

    // If TTML parsing fails, try standard XML
    if (segments.length === 0) {
        return parseXML(ttmlText)
    }

    return segments
}

function parseVTTFormat(vttText) {
    const segments = []
    const lines = vttText.split('\n')
    let i = 0

    while (i < lines.length) {
        const line = lines[i].trim()

        if (line.includes('-->')) {
            const [startStr, endStr] = line.split('-->').map(t => t.trim())
            const start = parseVTTTime(startStr)
            const end = parseVTTTime(endStr)

            i++
            let text = ''
            while (i < lines.length && lines[i].trim() !== '' && !lines[i].includes('-->')) {
                text += lines[i].trim() + ' '
                i++
            }

            text = text.trim().replace(/<[^>]+>/g, '').replace(/\s+/g, ' ')

            if (text) {
                segments.push({
                    start,
                    duration: end - start,
                    text
                })
            }
        }
        i++
    }

    return segments
}

function parseTTMLTime(timestamp) {
    // TTML format: HH:MM:SS.mmm or HH:MM:SS:frames
    const parts = timestamp.split(':')

    if (parts.length === 3) {
        const [h, m, s] = parts
        return parseFloat(h) * 3600 + parseFloat(m) * 60 + parseFloat(s)
    } else if (parts.length === 2) {
        const [m, s] = parts
        return parseFloat(m) * 60 + parseFloat(s)
    }

    return parseFloat(parts[0])
}

function parseVTTTime(timestamp) {
    const parts = timestamp.split(':')

    if (parts.length === 3) {
        const [h, m, s] = parts
        return parseFloat(h) * 3600 + parseFloat(m) * 60 + parseFloat(s)
    } else if (parts.length === 2) {
        const [m, s] = parts
        return parseFloat(m) * 60 + parseFloat(s)
    }
    return parseFloat(parts[0])
}

function decodeHTML(text) {
    const entities = {
        '&amp;': '&',
        '&lt;': '<',
        '&gt;': '>',
        '&quot;': '"',
        '&#39;': "'",
        '&nbsp;': ' '
    }
    return text.replace(/&[^;]+;/g, m => entities[m] || m)
}

export const strategy = {
    name: 'Piped API',
    priority: 2.5,
    fetch: fetchViaPiped
}
