/**
 * Piped API Service
 * Privacy-friendly YouTube frontend with comprehensive API
 * Documentation: https://docs.piped.video/docs/api-documentation/
 */

const FALLBACK_INSTANCES = [
    'https://api.piped.private.coffee',
    'https://pipedapi.adminforge.de',
    'https://pipedapi.kavin.rocks',
    'https://api-piped.mha.fi',
    'https://pipedapi.aeong.one'
]

let cachedInstancesList = null
let instancesListCacheTime = 0
const INSTANCES_LIST_CACHE_DURATION = 5 * 60 * 1000 // 5 minutes

let workingInstance = null
let lastInstanceCheck = 0
const INSTANCE_CHECK_INTERVAL = 5 * 60 * 1000 // 5 minutes

class Logger {
    constructor(prefix) {
        this.prefix = prefix
    }

    info(message, ...args) {
        console.log(`[${this.prefix}] ‚ÑπÔ∏è ${message}`, ...args)
    }

    success(message, ...args) {
        console.log(`[${this.prefix}] ‚úÖ ${message}`, ...args)
    }

    warn(message, ...args) {
        console.warn(`[${this.prefix}] ‚ö†Ô∏è ${message}`, ...args)
    }

    error(message, ...args) {
        console.error(`[${this.prefix}] ‚ùå ${message}`, ...args)
    }

    debug(message, ...args) {
        console.debug(`[${this.prefix}] üîç ${message}`, ...args)
    }
}

const logger = new Logger('Piped')

/**
 * Find a working Piped instance
 */
async function findWorkingInstance() {
    const now = Date.now()

    if (workingInstance && (now - lastInstanceCheck) < INSTANCE_CHECK_INTERVAL) {
        logger.debug(`Using cached instance: ${workingInstance}`)
        return workingInstance
    }

    logger.info('Finding working Piped instance...')

    const instances = await getInstancesList()

    for (const instance of instances) {
        try {
            logger.debug(`Testing instance: ${instance}`)
            const response = await fetch(`${instance}/trending?region=US`, {
                method: 'GET',
                signal: AbortSignal.timeout(5000)
            })

            if (response.ok) {
                logger.success(`Found working instance: ${instance}`)
                workingInstance = instance
                lastInstanceCheck = now
                return instance
            }
        } catch (error) {
            logger.warn(`Instance ${instance} failed:`, error.message)
        }
    }

    throw new Error('No working Piped instance found')
}

/**
 * Get list of Piped instances
 */
async function getInstancesList() {
    const now = Date.now()

    if (cachedInstancesList && (now - instancesListCacheTime) < INSTANCES_LIST_CACHE_DURATION) {
        logger.debug(`Using cached instances (${cachedInstancesList.length} instances)`)
        return cachedInstancesList
    }

    logger.info('Using fallback instance list')
    cachedInstancesList = FALLBACK_INSTANCES
    instancesListCacheTime = now
    return FALLBACK_INSTANCES
}

/**
 * Fetch video streams data (includes subtitles, metadata, etc.)
 */
export async function fetchVideoStreams(videoId) {
    logger.info(`Fetching video streams for: ${videoId}`)

    const instance = await findWorkingInstance()
    const url = `${instance}/streams/${videoId}`

    logger.debug(`Request URL: ${url}`)

    try {
        const response = await fetch(url, {
            method: 'GET',
            signal: AbortSignal.timeout(10000)
        })

        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`)
        }

        const data = await response.json()

        logger.success(`Video streams fetched successfully`, {
            title: data.title,
            uploader: data.uploader,
            duration: data.duration,
            subtitlesAvailable: data.subtitles?.length || 0
        })

        return data
    } catch (error) {
        logger.error(`Failed to fetch video streams:`, error.message)
        throw error
    }
}

/**
 * Fetch subtitles/transcript
 */
export async function fetchSubtitles(videoId, lang = 'en') {
    logger.info(`Fetching subtitles for: ${videoId} (lang: ${lang})`)

    try {
        const videoData = await fetchVideoStreams(videoId)

        if (!videoData.subtitles || videoData.subtitles.length === 0) {
            throw new Error('No subtitles available for this video')
        }

        logger.debug(`Available subtitles:`, videoData.subtitles.map(s => ({
            name: s.name,
            code: s.code,
            autoGenerated: s.autoGenerated
        })))

        // Find subtitle track for requested language
        let subtitle = videoData.subtitles.find(s => s.code === lang && !s.autoGenerated)

        if (!subtitle) {
            subtitle = videoData.subtitles.find(s => s.code === lang)
        }

        if (!subtitle) {
            logger.warn(`Language '${lang}' not found, using fallback: ${videoData.subtitles[0].code}`)
            subtitle = videoData.subtitles[0]
        }

        logger.debug(`Selected subtitle track:`, {
            name: subtitle.name,
            code: subtitle.code,
            autoGenerated: subtitle.autoGenerated,
            mimeType: subtitle.mimeType
        })

        // Fetch subtitle content
        const response = await fetch(subtitle.url, {
            signal: AbortSignal.timeout(10000)
        })

        if (!response.ok) {
            throw new Error(`Failed to fetch subtitles: HTTP ${response.status}`)
        }

        const subtitleText = await response.text()
        logger.debug(`Subtitle data received, length: ${subtitleText.length} bytes`)

        return {
            text: subtitleText,
            mimeType: subtitle.mimeType,
            code: subtitle.code,
            autoGenerated: subtitle.autoGenerated
        }
    } catch (error) {
        logger.error(`Failed to fetch subtitles:`, error.message)
        throw error
    }
}

/**
 * Fetch video metadata
 */
export async function fetchMetadata(videoId) {
    logger.info(`Fetching metadata for: ${videoId}`)

    try {
        const data = await fetchVideoStreams(videoId)

        const metadata = {
            videoId: videoId,
            title: data.title,
            uploader: data.uploader,
            uploaderUrl: data.uploaderUrl,
            uploaderVerified: data.uploaderVerified,
            duration: data.duration,
            views: data.views,
            likes: data.likes,
            dislikes: data.dislikes,
            uploadDate: data.uploadDate,
            description: data.description,
            thumbnailUrl: data.thumbnailUrl,
            livestream: data.livestream,
            subtitlesAvailable: (data.subtitles?.length || 0) > 0,
            availableLanguages: data.subtitles?.map(s => s.code) || []
        }

        logger.success('Metadata extracted successfully')
        return metadata
    } catch (error) {
        logger.error('Failed to fetch metadata:', error.message)
        throw error
    }
}

/**
 * Fetch video comments
 */
export async function fetchComments(videoId, nextpage = null) {
    logger.info(`Fetching comments for: ${videoId}`)

    const instance = await findWorkingInstance()
    const url = nextpage
        ? `${instance}/nextpage/comments/${videoId}?nextpage=${encodeURIComponent(nextpage)}`
        : `${instance}/comments/${videoId}`

    try {
        const response = await fetch(url, {
            signal: AbortSignal.timeout(10000)
        })

        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`)
        }

        const data = await response.json()
        logger.success(`Fetched ${data.comments?.length || 0} comments`)

        return data
    } catch (error) {
        logger.error('Failed to fetch comments:', error.message)
        throw error
    }
}

/**
 * Search videos
 */
export async function searchVideos(query, filter = 'all') {
    logger.info(`Searching for: ${query}`)

    const instance = await findWorkingInstance()
    const url = `${instance}/search?q=${encodeURIComponent(query)}&filter=${filter}`

    try {
        const response = await fetch(url, {
            signal: AbortSignal.timeout(10000)
        })

        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`)
        }

        const data = await response.json()
        logger.success(`Found ${data.items?.length || 0} results`)

        return data
    } catch (error) {
        logger.error('Search failed:', error.message)
        throw error
    }
}

/**
 * Get trending videos
 */
export async function fetchTrending(region = 'US') {
    logger.info(`Fetching trending videos for region: ${region}`)

    const instance = await findWorkingInstance()
    const url = `${instance}/trending?region=${region}`

    try {
        const response = await fetch(url, {
            signal: AbortSignal.timeout(10000)
        })

        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`)
        }

        const data = await response.json()
        logger.success(`Fetched ${data.length} trending videos`)

        return data
    } catch (error) {
        logger.error('Failed to fetch trending:', error.message)
        throw error
    }
}
